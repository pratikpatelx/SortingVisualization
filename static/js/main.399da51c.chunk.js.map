{"version":3,"sources":["SortingAlgorithms/MergeSort.js","SortingAlgorithms/InsertionSort.js","SortingAlgorithms/BubbleSort.js","SortingAlgorithms/HeapSort.js","SortingAlgorithms/QuickSort.js","SortingVisualizer/SortingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["MergeSort","arr","copy","len","length","animations","mergeSortHelper","Array","aux","left","right","mid","Math","floor","index","i","j","k","push","merge","swapElements","array","tempIndex","temp","BubbleSort","lastSorted","bubblesortHelper","HeapSort","arrLen","heapify","heapSortHelper","size","largest","QuickSort","copyArr","quickSortHelper","leftStart","rightEnd","pivot","leftIndex","rightIndex","startPartition","MAX_DELAY","PRIMARY_COLOR","SORTED_COLOR","SortingVisualizer","props","useState","setArray","startSorting","setstartSorting","isSorted","setisSorted","nodeRef","useRef","resetArray","arrBars","current","children","style","backgroundColor","resetArrayColor","min","max","tempArray","random","updateAnimation","forEach","comparison","swapped","setTimeout","prevArray","newValue","newArray","setArrayAccessAnimation","arrayBars","arrayBarStyle","animateSortedArray","useEffect","Navbar","bg","variant","className","Brand","Toggle","aria-controls","Collapse","id","Nav","Link","onClick","InsertionSort","ref","map","value","idx","height","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.399da51c.chunk.js","sourcesContent":["/*\r\nAuthor: Pratik Patel\r\nPurpose: MergeSort.js contains the implementation of the MergeSort algorithm \r\n*/\r\nexport function MergeSort(arr) {\r\n  //copy the contents of the array into a new array\r\n  const copy = [...arr];\r\n  //the length of the array that we copied\r\n  const len = copy.length;\r\n  //a new array object of the correct length\r\n  const aux = Array(len);\r\n  //a new animations array\r\n  const animations = [];\r\n  //helper method to do the splitting into halves\r\n  mergeSortHelper(copy, aux, 0, len - 1, animations);\r\n  return animations;\r\n}\r\n\r\nfunction mergeSortHelper(arr, aux, left, right, animations) {\r\n  if (right <= left) return;\r\n  const mid = left + Math.floor((right - left) / 2);\r\n  mergeSortHelper(arr, aux, left, mid, animations);\r\n  mergeSortHelper(arr, aux, mid + 1, right, animations);\r\n  merge(arr, aux, left, mid, right, animations);\r\n}\r\n\r\nfunction merge(arr, aux, left, mid, right, animations) {\r\n  for (let index = left; index <= right; index++) {\r\n    aux[index] = arr[index];\r\n  }\r\n  let i = left;\r\n  let j = mid + 1;\r\n  //console.log(aux);\r\n  //console.log(arr);\r\n  for (let k = left; k <= right; k++) {\r\n    if (i > mid) {\r\n      animations.push([[j], false]);\r\n      animations.push([[k, aux[j]], true]);\r\n      arr[k] = aux[j++];\r\n    } else if (j > right) {\r\n      animations.push([[i], false]);\r\n      animations.push([[k, aux[i]], true]);\r\n      arr[k] = aux[i++];\r\n    } else if (aux[j] < aux[i]) {\r\n      animations.push([[i, j], false]);\r\n      animations.push([[k, aux[j]], true]);\r\n      arr[k] = aux[j++];\r\n    } else {\r\n      animations.push([[i, j], false]);\r\n      animations.push([[k, aux[i]], true]);\r\n      arr[k] = aux[i++];\r\n    }\r\n  }\r\n}\r\n","/*\r\nAuthor: Pratik Patel\r\nPurpose: InsertionSort.js contains the implementation of the InsertionSort algorithm \r\n*/\r\nexport function swapElements(array, index, tempIndex) {\r\n  const temp = array[index];\r\n  array[index] = array[tempIndex];\r\n  array[tempIndex] = temp;\r\n}\r\n\r\nexport function InsertionSort(array) {\r\n  const copyArr = [...array];\r\n  const animations = [];\r\n  for (let index = 1; index < copyArr.length; index++) {\r\n    for (let j = index - 1; j >= 0; j--) {\r\n      animations.push([[j, j + 1], false]);\r\n      if (copyArr[j + 1] < copyArr[j]) {\r\n        animations.push([[j, copyArr[j + 1]], true]);\r\n        animations.push([[j + 1, copyArr[j]], true]);\r\n        swapElements(copyArr, j, j + 1);\r\n      }\r\n    }\r\n  }\r\n  return animations;\r\n}\r\n","/*\r\nAuthor: Pratik Patel\r\nPurpose: BubbleSort.js contains the implementation of the BubbleSort algorithm \r\n*/\r\nimport { swapElements } from \"./InsertionSort\";\r\n\r\n/* The purpose of this function is that it does the bubble sort implementation by calling an helper method\r\nwhich does the actual bubble sorting implementation */\r\nexport function BubbleSort(array) {\r\n  //the animations array\r\n  const animations = [];\r\n  //helper method that does the bubble sort\r\n  bubblesortHelper(array, animations);\r\n  return animations;\r\n}\r\n/* This function does the actual comparison based sorting using the bubble sort algorithm*/\r\nfunction bubblesortHelper(array, animations) {\r\n  //the last position of the array\r\n  const lastSorted = array.length - 1;\r\n  for (let i = 0; i < lastSorted; i++) {\r\n    for (let j = 0; j < lastSorted - i; j++) {\r\n      animations.push([[j, j + 1], false]);\r\n      animations.push([[j, j + 1], false]);\r\n      //check if value is greater than the other value in the array, if it is then swap\r\n      if (array[j] > array[j + 1]) {\r\n        animations.push([[j, array[j + 1]], true]);\r\n        animations.push([[j + 1, array[j]], true]);\r\n        //swap the values\r\n        swapElements(array, j, j + 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default BubbleSort;\r\n","export function HeapSort(array) {\r\n  const animations = [];\r\n  if (array.length <= 1) {\r\n    return array;\r\n  }\r\n  heapSortHelper(array, animations);\r\n  return animations;\r\n}\r\n\r\nfunction heapSortHelper(array, animations) {\r\n  let arrLen = array.length;\r\n  for (let i = arrLen / 2 - 1; i >= 0; i--) {\r\n    heapify(array, arrLen, i, animations);\r\n  }\r\n\r\n  for (let j = arrLen - 1; j > 0; j--) {\r\n    animations.push([[0, array[j]], true]);\r\n    animations.push([[j, array[0]], true]);\r\n    [array[0], array[j]] = [array[j], array[0]];\r\n    heapify(array, j, 0, animations);\r\n  }\r\n}\r\n\r\nfunction heapify(array, size, i, animations) {\r\n  let largest = i;\r\n  let left = 2 * i + 1;\r\n  let right = 2 * i + 2;\r\n\r\n  if (left < size && array[i] < array[left]) {\r\n    animations.push([i, left, true]);\r\n    animations.push([i, left, true]);\r\n    largest = left;\r\n  }\r\n\r\n  if (right < size && array[largest] < array[right]) {\r\n    animations.push([i, right, true]);\r\n    animations.push([i, right, false]);\r\n    largest = right;\r\n  }\r\n\r\n  if (largest !== i) {\r\n    animations.push([i, array[largest], true]);\r\n    animations.push([largest, array[i], true]);\r\n    [array[i], array[largest]] = [array[largest], array[i]];\r\n\r\n    heapify(array, size, largest, animations);\r\n  }\r\n}\r\n","/*\r\nAuthor: Pratik Patel\r\nPurpose: QuickSort.js contains the implementation of the QuickSort algorithm \r\n*/\r\n//Importing the swap function defined in Insertion Sort\r\nimport { swapElements } from \"./InsertionSort\";\r\n\r\n/* This function is used to get the animation's array for our quick sort implementation,\r\nit calls a helper method which does the actual quick sort implementation\r\nParameters: array - The array which is passed to be sorted\r\nReturns: an animations 2D array which contains the values of each elements in the array in sorted order\r\n */\r\nexport function QuickSort(array) {\r\n  //copy the contents of the array into a new temporary array\r\n  const copyArr = [...array];\r\n  //the length of the array we just copied\r\n  const maxLen = copyArr.length - 1;\r\n  //the animations array that will store the compared values\r\n  const animations = [];\r\n  //the method that does the actual quick sort implementation\r\n  quickSortHelper(copyArr, 0, maxLen, animations);\r\n  return animations;\r\n}\r\n\r\n/*This method does the quick sort implementation recursively, it calculates the pivot position and calls another function\r\nthat does the partition of the array from the pivot\r\nParameters: array - the array to be sorted\r\n            leftStart - the starting position of the array\r\n            rightEnd - the last position of the array\r\n            animations - the animations array\r\n*/\r\nfunction quickSortHelper(array, leftStart, rightEnd, animations) {\r\n  //check if left index is equal to the right index then we have nothing to compare!\r\n  if (leftStart <= rightEnd) {\r\n    return;\r\n  }\r\n  //get the pivot the point at which we will compare the values\r\n  const pivot = startPartition(array, leftStart, rightEnd, animations);\r\n  //sort the first half of the array to the pivot\r\n  quickSortHelper(array, leftStart, pivot, animations);\r\n  //sort the second half of the array from the pivot to the end of the array\r\n  quickSortHelper(array, pivot + 1, rightEnd, animations);\r\n}\r\n\r\n/* This functions does the partition of the array from the pivot and adds the sorted values to the animations array\r\nParameters: array - the array to be partitioned and sorted\r\n            leftStart - the starting index of the array\r\n            rightEnd - the last index of the array\r\n            animations - the animations array\r\n*/\r\nfunction startPartition(array, leftStart, rightEnd, animations) {\r\n  //get the starting index\r\n  let leftIndex = leftStart;\r\n  // get the end of the array index\r\n  let rightIndex = rightEnd + 1;\r\n  // shows where the pivot is\r\n  const pivot = array[leftStart];\r\n  while (true) {\r\n    while (array[leftIndex++] <= pivot) {\r\n      if (rightEnd === leftIndex) {\r\n        break;\r\n      }\r\n      animations.push([leftIndex], false);\r\n    }\r\n    while (array[rightIndex--] >= pivot) {\r\n      if (rightIndex === leftStart) {\r\n        break;\r\n      }\r\n      animations.push([rightIndex], false);\r\n    }\r\n    if (rightIndex <= leftIndex) {\r\n      break;\r\n    }\r\n    animations.push([[leftIndex, array[rightIndex]], true]);\r\n    animations.push([[rightIndex, array[leftIndex]], true]);\r\n    swapElements(array, leftIndex, rightIndex);\r\n  }\r\n  animations.push([[leftStart, array[rightIndex]], true]);\r\n  animations.push([[rightIndex, array[leftStart]], true]);\r\n  swapElements(array, leftStart, rightIndex);\r\n  return rightIndex;\r\n}\r\n","import React, { useState, useRef, useEffect } from \"react\";\r\nimport \"./SortingVisualizer.css\";\r\nimport { Navbar, Nav } from \"react-bootstrap\";\r\nimport { MergeSort } from \"../SortingAlgorithms/MergeSort\";\r\nimport { BubbleSort } from \"../SortingAlgorithms/BubbleSort\";\r\nimport { InsertionSort } from \"../SortingAlgorithms/InsertionSort\";\r\nimport { HeapSort } from \"../SortingAlgorithms/HeapSort\";\r\nimport { QuickSort } from \"../SortingAlgorithms/QuickSort\";\r\n\r\n//Maximum Array Size\r\nconst MAX_ARR_LEN = 100;\r\n\r\n//Maximum Delay of Animation (used in Timeouts)\r\nconst MAX_DELAY = 20;\r\n\r\n// This is the main color of the array bars before sorted.\r\nconst PRIMARY_COLOR = \"#6399F1\";\r\n\r\n// This is the colour of the Bars after they are sorted\r\nconst SORTED_COLOR = \"#B578E8\";\r\n\r\n// This is the color of the comparison bar that will be compared based on the comparison\r\nconst COMPARISON_COLOR_1 = \"#B22222\";\r\n// This is the color of the comparison bar that will be compared based on the comparison\r\nconst COMPARISON_COLOR_2 = \"#FFA500\";\r\n\r\nfunction SortingVisualizer(props) {\r\n  //Declare a new state variable called array that will store the elements to be sorted\r\n  const [array, setArray] = useState([]);\r\n\r\n  //A new state variable that tells us if we are sorting the array or not\r\n  const [startSorting, setstartSorting] = useState(false);\r\n\r\n  //A new state variable that checks if array is sorted or not\r\n  const [isSorted, setisSorted] = useState(false);\r\n\r\n  //Need this Ref to access the DOM nodes\r\n  const nodeRef = useRef(null);\r\n\r\n  //similar to componentDidMount we want to load a new array each time we load the page\r\n  useEffect(() => {\r\n    resetArray();\r\n    // eslint-disable-next-line\r\n  }, []);\r\n\r\n  //This function resets the contents of the array each time we reload the page a new array will be generated\r\n  // with random values\r\n  function resetArray() {\r\n    //check if we are sorting the array\r\n    if (startSorting) {\r\n      return;\r\n    }\r\n    //check if array is already sorted then we just reset the color of the array contents i.e bars\r\n    if (isSorted) {\r\n      resetArrayColor();\r\n    }\r\n\r\n    //our array is not sorted\r\n    setisSorted(false);\r\n\r\n    // create a new temporary array\r\n    const tempArray = [];\r\n    //assign random values to the temporary array\r\n    for (let index = 0; index < MAX_ARR_LEN; index++) {\r\n      tempArray.push(randomIntFromInterval(5, 600));\r\n    }\r\n    // set the state of the array\r\n    setArray(tempArray);\r\n  }\r\n\r\n  /*This function resets the Array Colour once we have generated a new array\r\n  so the colour of the bars will change to Blue once a new array is generated for sorting\r\n   */\r\n  function resetArrayColor() {\r\n    const arrBars = nodeRef.current.children;\r\n    for (let i = 0; i < array.length; i++) {\r\n      const arrBarStyle = arrBars[i].style;\r\n      arrBarStyle.backgroundColor = PRIMARY_COLOR;\r\n    }\r\n  }\r\n\r\n  /*This function does the mergeSort on the array, it  invokes the MergeSort function\r\n   from the src/SortingAlgorithms/MergeSort.js which contains the actual implementation of the merge sort algorithm */\r\n  function mergeSort() {\r\n    const animationsArr = MergeSort(array);\r\n    updateAnimation(animationsArr);\r\n  }\r\n\r\n  /*This function does the bubbleSort on the array, it  invokes the BubbleSort function\r\n   from the src/SortingAlgorithms/BubbleSort.js which contains the actual implementation of the bubble sort algorithm */\r\n  function bubbleSort() {\r\n    const animationsArr = BubbleSort(array);\r\n    updateAnimation(animationsArr);\r\n  }\r\n\r\n  /*This function does the insertionSort on the array, it  invokes the InsertionSort function\r\n   from the src/SortingAlgorithms/InsertionSort.js which contains the actual implementation of the insertion sort algorithm */\r\n  function insertionSort() {\r\n    const animationsArr = InsertionSort(array);\r\n    updateAnimation(animationsArr);\r\n  }\r\n\r\n  function heapSort() {\r\n    const animationsArr = HeapSort(array);\r\n    updateAnimation(animationsArr);\r\n  }\r\n\r\n  function quickSort() {\r\n    const animationsArr = QuickSort(array);\r\n    updateAnimation(animationsArr);\r\n  }\r\n\r\n  /*This function updates the animations on the bars, it compares the values of the bars and then updates the animation of\r\n  the bars according to the value of the array\r\n   */\r\n  function updateAnimation(animations) {\r\n    if (startSorting) {\r\n      return;\r\n    }\r\n    setstartSorting(true);\r\n    animations.forEach(([comparison, swapped], index) => {\r\n      setTimeout(() => {\r\n        if (!swapped) {\r\n          if (comparison.length === 2) {\r\n            const [i, j] = comparison;\r\n            setArrayAccessAnimation(i);\r\n            setArrayAccessAnimation(j);\r\n          } else {\r\n            const [i] = comparison;\r\n            setArrayAccessAnimation(i);\r\n          }\r\n        } else {\r\n          setArray((prevArray) => {\r\n            const [k, newValue] = comparison;\r\n            const newArray = [...prevArray];\r\n            newArray[k] = newValue;\r\n            return newArray;\r\n          });\r\n        }\r\n      }, index * MAX_DELAY);\r\n    });\r\n    setTimeout(() => {\r\n      animateSortedArray();\r\n    }, animations.length * MAX_DELAY);\r\n  }\r\n\r\n  function setArrayAccessAnimation(index) {\r\n    const arrayBars = nodeRef.current.children;\r\n    const arrayBarStyle = arrayBars[index].style;\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = COMPARISON_COLOR_1;\r\n    }, MAX_DELAY);\r\n\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = COMPARISON_COLOR_2;\r\n    }, MAX_DELAY * 2);\r\n  }\r\n\r\n  function animateSortedArray() {\r\n    const arrayBars = nodeRef.current.children;\r\n    for (let index = 0; index < arrayBars.length; index++) {\r\n      const arrayBarStyle = arrayBars[index].style;\r\n      setTimeout(\r\n        () => (arrayBarStyle.backgroundColor = SORTED_COLOR),\r\n        index * MAX_DELAY\r\n      );\r\n    }\r\n    setTimeout(() => {\r\n      setisSorted(true);\r\n      setstartSorting(false);\r\n    }, arrayBars.length * MAX_DELAY);\r\n  }\r\n  return (\r\n    <>\r\n      <Navbar bg=\"dark\" variant=\"dark\" className=\"topnav\">\r\n        <Navbar.Brand>Sorting Visualization</Navbar.Brand>\r\n        <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\r\n        <Navbar.Collapse id=\"responsive-navbar-nav\">\r\n          <Nav className=\"mr-auto\">\r\n            <Nav.Link onClick={resetArray}>Generate New Array</Nav.Link>\r\n            <Nav.Link onClick={bubbleSort}>Bubble Sort</Nav.Link>\r\n            <Nav.Link onClick={insertionSort}>Insertion Sort</Nav.Link>\r\n            <Nav.Link onClick={heapSort}>Heap Sort</Nav.Link>\r\n            <Nav.Link onClick={mergeSort}>Merge Sort</Nav.Link>\r\n            <Nav.Link onClick={quickSort}>Quick Sort</Nav.Link>\r\n          </Nav>\r\n        </Navbar.Collapse>\r\n      </Navbar>\r\n      <div className=\"array-container\" ref={nodeRef}>\r\n        {array.map((value, idx) => (\r\n          <div\r\n            className=\"array-bar\"\r\n            style={{ backgroundColor: PRIMARY_COLOR, height: `${value}px` }}\r\n            key={idx}\r\n          ></div>\r\n        ))}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nfunction randomIntFromInterval(min, max) {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\nexport default SortingVisualizer;\r\n","import React from \"react\";\nimport \"./App.css\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\n// Importing the Bootstrap CSS\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}