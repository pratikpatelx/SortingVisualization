{"version":3,"sources":["SortingAlgorithms/MergeSort.js","SortingAlgorithms/InsertionSort.js","SortingAlgorithms/BubbleSort.js","SortingAlgorithms/QuickSort.js","SortingVisualizer/SortingVisualizer.js","App.js","reportWebVitals.js","index.js"],"names":["MergeSort","arr","copy","len","length","animations","mergeSortHelper","Array","aux","left","right","mid","Math","floor","index","i","j","k","push","merge","swapElements","array","tempIndex","temp","BubbleSort","lastSorted","bubblesortHelper","QuickSort","quickSortHelper","part","pivot","partition","MAX_DELAY","PRIMARY_COLOR","SORTED_COLOR","SortingVisualizer","props","useState","setArray","startSorting","setstartSorting","isSorted","setisSorted","nodeRef","useRef","resetArray","arrBars","current","children","style","backgroundColor","resetArrayColor","min","max","tempArray","random","updateAnimation","forEach","comparison","swapped","setTimeout","prevArray","newValue","newArray","setArrayAccessAnimation","arrayBars","arrayBarStyle","animateSortedArray","useEffect","Navbar","bg","variant","className","Brand","Toggle","aria-controls","Collapse","id","Nav","Link","onClick","copyArr","InsertionSort","ref","map","value","idx","height","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.656142c3.chunk.js","sourcesContent":["/*\r\nAuthor: Pratik Patel\r\nPurpose: MergeSort.js contains the implementation of the MergeSort algorithm \r\n*/\r\nexport function MergeSort(arr) {\r\n  //copy the contents of the array into a new array\r\n  const copy = [...arr];\r\n  //the length of the array that we copied\r\n  const len = copy.length;\r\n  //a new array object of the correct length\r\n  const aux = Array(len);\r\n  //a new animations array\r\n  const animations = [];\r\n  //helper method to do the splitting into halves\r\n  mergeSortHelper(copy, aux, 0, len - 1, animations);\r\n  return animations;\r\n}\r\n\r\nfunction mergeSortHelper(arr, aux, left, right, animations) {\r\n  if (right <= left) return;\r\n  const mid = left + Math.floor((right - left) / 2);\r\n  mergeSortHelper(arr, aux, left, mid, animations);\r\n  mergeSortHelper(arr, aux, mid + 1, right, animations);\r\n  merge(arr, aux, left, mid, right, animations);\r\n}\r\n\r\nfunction merge(arr, aux, left, mid, right, animations) {\r\n  for (let index = left; index <= right; index++) {\r\n    aux[index] = arr[index];\r\n  }\r\n  let i = left;\r\n  let j = mid + 1;\r\n  //console.log(aux);\r\n  //console.log(arr);\r\n  for (let k = left; k <= right; k++) {\r\n    if (i > mid) {\r\n      animations.push([[j], false]);\r\n      animations.push([[k, aux[j]], true]);\r\n      arr[k] = aux[j++];\r\n    } else if (j > right) {\r\n      animations.push([[i], false]);\r\n      animations.push([[k, aux[i]], true]);\r\n      arr[k] = aux[i++];\r\n    } else if (aux[j] < aux[i]) {\r\n      animations.push([[i, j], false]);\r\n      animations.push([[k, aux[j]], true]);\r\n      arr[k] = aux[j++];\r\n    } else {\r\n      animations.push([[i, j], false]);\r\n      animations.push([[k, aux[i]], true]);\r\n      arr[k] = aux[i++];\r\n    }\r\n  }\r\n}\r\n","/*\r\nAuthor: Pratik Patel\r\nPurpose: InsertionSort.js contains the implementation of the InsertionSort algorithm \r\n*/\r\nexport function swapElements(array, index, tempIndex) {\r\n  const temp = array[index];\r\n  array[index] = array[tempIndex];\r\n  array[tempIndex] = temp;\r\n}\r\n\r\nexport function InsertionSort(array) {\r\n  const copyArr = [...array];\r\n  const animations = [];\r\n  for (let index = 1; index < copyArr.length; index++) {\r\n    for (let j = index - 1; j >= 0; j--) {\r\n      animations.push([[j, j + 1], false]);\r\n      if (copyArr[j + 1] < copyArr[j]) {\r\n        animations.push([[j, copyArr[j + 1]], true]);\r\n        animations.push([[j + 1, copyArr[j]], true]);\r\n        swapElements(copyArr, j, j + 1);\r\n      }\r\n    }\r\n  }\r\n  return animations;\r\n}\r\n","/*\r\nAuthor: Pratik Patel\r\nPurpose: BubbleSort.js contains the implementation of the BubbleSort algorithm \r\n*/\r\nimport { swapElements } from \"./InsertionSort\";\r\n\r\n/* The purpose of this function is that it does the bubble sort implementation by calling an helper method\r\nwhich does the actual bubble sorting implementation */\r\nexport function BubbleSort(array) {\r\n  //the animations array\r\n  const animations = [];\r\n  //helper method that does the bubble sort\r\n  bubblesortHelper(array, animations);\r\n  return animations;\r\n}\r\n/* This function does the actual comparison based sorting using the bubble sort algorithm*/\r\nfunction bubblesortHelper(array, animations) {\r\n  //the last position of the array\r\n  const lastSorted = array.length - 1;\r\n  for (let i = 0; i < lastSorted; i++) {\r\n    for (let j = 0; j < lastSorted - i; j++) {\r\n      animations.push([[j, j + 1], false]);\r\n      animations.push([[j, j + 1], false]);\r\n      //check if value is greater than the other value in the array, if it is then swap\r\n      if (array[j] > array[j + 1]) {\r\n        animations.push([[j, array[j + 1]], true]);\r\n        animations.push([[j + 1, array[j]], true]);\r\n        //swap the values\r\n        swapElements(array, j, j + 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport default BubbleSort;\r\n","/*\r\nAuthor: Pratik Patel\r\nPurpose: QuickSort.js contains the implementation of the QuickSort algorithm \r\n*/\r\n//Importing the swap function defined in Insertion Sort\r\nimport { swapElements } from \"./InsertionSort\";\r\n\r\nexport function QuickSort(arr) {\r\n  const copy = [...arr];\r\n  const animations = [];\r\n  quickSortHelper(copy, 0, copy.length - 1, animations);\r\n  return animations;\r\n}\r\n\r\nfunction quickSortHelper(arr, left, right, animations) {\r\n  if (right <= left) return;\r\n  const part = partition(arr, left, right, animations);\r\n  quickSortHelper(arr, left, part, animations);\r\n  quickSortHelper(arr, part + 1, right, animations);\r\n}\r\n\r\nfunction partition(arr, left, right, animations) {\r\n  let i = left;\r\n  let j = right + 1;\r\n  const pivot = arr[left];\r\n  while (true) {\r\n    while (arr[++i] <= pivot) {\r\n      if (i === right) break;\r\n      animations.push([[i], false]);\r\n    }\r\n    while (arr[--j] >= pivot) {\r\n      if (j === left) break;\r\n      animations.push([[j], false]);\r\n    }\r\n    if (j <= i) break;\r\n    animations.push([[i, arr[j]], true]);\r\n    animations.push([[j, arr[i]], true]);\r\n    swapElements(arr, i, j);\r\n  }\r\n  animations.push([[left, arr[j]], true]);\r\n  animations.push([[j, arr[left]], true]);\r\n  swapElements(arr, left, j);\r\n  return j;\r\n}\r\n\r\n// /* This function is used to get the animation's array for our quick sort implementation,\r\n// it calls a helper method which does the actual quick sort implementation\r\n// Parameters: array - The array which is passed to be sorted\r\n// Returns: an animations 2D array which contains the values of each elements in the array in sorted order\r\n//  */\r\n// export function QuickSort(array) {\r\n//   //copy the contents of the array into a new temporary array\r\n//   const copyArr = [...array];\r\n//   //the length of the array we just copied\r\n//   const maxLen = copyArr.length - 1;\r\n//   //the animations array that will store the compared values\r\n//   const animations = [];\r\n//   //the method that does the actual quick sort implementation\r\n//   quickSortHelper(copyArr, 0, maxLen, animations);\r\n//   return animations;\r\n// }\r\n\r\n// /*This method does the quick sort implementation recursively, it calculates the pivot position and calls another function\r\n// that does the partition of the array from the pivot\r\n// Parameters: array - the array to be sorted\r\n//             leftStart - the starting position of the array\r\n//             rightEnd - the last position of the array\r\n//             animations - the animations array\r\n// */\r\n// function quickSortHelper(array, leftStart, rightEnd, animations) {\r\n//   //check if left index is equal to the right index then we have nothing to compare!\r\n//   if (leftStart <= rightEnd) {\r\n//     return;\r\n//   }\r\n//   //get the pivot the point at which we will compare the values\r\n//   const pivot = startPartition(array, leftStart, rightEnd, animations);\r\n//   //sort the first half of the array to the pivot\r\n//   quickSortHelper(array, leftStart, pivot, animations);\r\n//   //sort the second half of the array from the pivot to the end of the array\r\n//   quickSortHelper(array, pivot + 1, rightEnd, animations);\r\n// }\r\n\r\n// /* This functions does the partition of the array from the pivot and adds the sorted values to the animations array\r\n// Parameters: array - the array to be partitioned and sorted\r\n//             leftStart - the starting index of the array\r\n//             rightEnd - the last index of the array\r\n//             animations - the animations array\r\n// */\r\n// function startPartition(array, leftStart, rightEnd, animations) {\r\n//   //get the starting index\r\n//   let leftIndex = leftStart;\r\n//   // get the end of the array index\r\n//   let rightIndex = rightEnd + 1;\r\n//   // shows where the pivot is\r\n//   const pivot = array[leftStart];\r\n//   while (true) {\r\n//     while (array[++leftIndex] <= pivot) {\r\n//       if (rightEnd === leftIndex) {\r\n//         break;\r\n//       }\r\n//       animations.push([leftIndex], false);\r\n//     }\r\n//     while (array[--rightIndex] >= pivot) {\r\n//       if (rightIndex === leftStart) {\r\n//         break;\r\n//       }\r\n//       animations.push([rightIndex], false);\r\n//     }\r\n//     if (rightIndex <= leftIndex) {\r\n//       break;\r\n//     }\r\n//     animations.push([[leftIndex, array[rightIndex]], true]);\r\n//     animations.push([[rightIndex, array[leftIndex]], true]);\r\n//     swapElements(array, leftIndex, rightIndex);\r\n//   }\r\n//   animations.push([[leftStart, array[rightIndex]], true]);\r\n//   animations.push([[rightIndex, array[leftStart]], true]);\r\n//   swapElements(array, leftStart, rightIndex);\r\n//   return rightIndex;\r\n// }\r\n","import React, { useState, useRef, useEffect } from \"react\";\r\nimport \"./SortingVisualizer.css\";\r\nimport { Navbar, Nav } from \"react-bootstrap\";\r\nimport { MergeSort } from \"../SortingAlgorithms/MergeSort\";\r\nimport { BubbleSort } from \"../SortingAlgorithms/BubbleSort\";\r\nimport { InsertionSort } from \"../SortingAlgorithms/InsertionSort\";\r\nimport { QuickSort } from \"../SortingAlgorithms/QuickSort\";\r\n\r\n//Maximum Array Size\r\nconst MAX_ARR_LEN = 100;\r\n\r\n//Maximum Delay of Animation (used in Timeouts)\r\nconst MAX_DELAY = 20;\r\n\r\n// This is the main color of the array bars before sorted.\r\nconst PRIMARY_COLOR = \"#6399F1\";\r\n\r\n// This is the colour of the Bars after they are sorted\r\nconst SORTED_COLOR = \"#B578E8\";\r\n\r\n// This is the color of the comparison bar that will be compared based on the comparison\r\nconst COMPARISON_COLOR_1 = \"#B22222\";\r\n// This is the color of the comparison bar that will be compared based on the comparison\r\nconst COMPARISON_COLOR_2 = \"#FFA500\";\r\n\r\nfunction SortingVisualizer(props) {\r\n  //Declare a new state variable called array that will store the elements to be sorted\r\n  const [array, setArray] = useState([]);\r\n\r\n  //A new state variable that tells us if we are sorting the array or not\r\n  const [startSorting, setstartSorting] = useState(false);\r\n\r\n  //A new state variable that checks if array is sorted or not\r\n  const [isSorted, setisSorted] = useState(false);\r\n\r\n  //Need this Ref to access the DOM nodes\r\n  const nodeRef = useRef(null);\r\n\r\n  //similar to componentDidMount we want to load a new array each time we load the page\r\n  useEffect(() => {\r\n    resetArray();\r\n    // eslint-disable-next-line\r\n  }, []);\r\n\r\n  //This function resets the contents of the array each time we reload the page a new array will be generated\r\n  // with random values\r\n  function resetArray() {\r\n    //check if we are sorting the array\r\n    if (startSorting) {\r\n      return;\r\n    }\r\n    //check if array is already sorted then we just reset the color of the array contents i.e bars\r\n    if (isSorted) {\r\n      resetArrayColor();\r\n    }\r\n\r\n    //our array is not sorted\r\n    setisSorted(false);\r\n\r\n    // create a new temporary array\r\n    const tempArray = [];\r\n    //assign random values to the temporary array\r\n    for (let index = 0; index < MAX_ARR_LEN; index++) {\r\n      tempArray.push(randomIntFromInterval(5, 600));\r\n    }\r\n    // set the state of the array\r\n    setArray(tempArray);\r\n  }\r\n\r\n  /*This function resets the Array Colour once we have generated a new array\r\n  so the colour of the bars will change to Blue once a new array is generated for sorting\r\n   */\r\n  function resetArrayColor() {\r\n    const arrBars = nodeRef.current.children;\r\n    for (let i = 0; i < array.length; i++) {\r\n      const arrBarStyle = arrBars[i].style;\r\n      arrBarStyle.backgroundColor = PRIMARY_COLOR;\r\n    }\r\n  }\r\n\r\n  /*This function does the mergeSort on the array, it  invokes the MergeSort function\r\n   from the src/SortingAlgorithms/MergeSort.js which contains the actual implementation of the merge sort algorithm */\r\n  function mergeSort() {\r\n    const animationsArr = MergeSort(array);\r\n    updateAnimation(animationsArr);\r\n  }\r\n\r\n  /*This function does the bubbleSort on the array, it  invokes the BubbleSort function\r\n   from the src/SortingAlgorithms/BubbleSort.js which contains the actual implementation of the bubble sort algorithm */\r\n  function bubbleSort() {\r\n    const animationsArr = BubbleSort(array);\r\n    updateAnimation(animationsArr);\r\n  }\r\n\r\n  /*This function does the insertionSort on the array, it  invokes the InsertionSort function\r\n   from the src/SortingAlgorithms/InsertionSort.js which contains the actual implementation of the insertion sort algorithm */\r\n  function insertionSort() {\r\n    const animationsArr = InsertionSort(array);\r\n    updateAnimation(animationsArr);\r\n  }\r\n\r\n  // function heapSort() {\r\n  //   const animationsArr = HeapSort(array);\r\n  //   updateAnimation(animationsArr);\r\n  // }\r\n\r\n  function quickSort() {\r\n    const animationsArr = QuickSort(array);\r\n    updateAnimation(animationsArr);\r\n  }\r\n\r\n  /*This function updates the animations on the bars, it compares the values of the bars and then updates the animation of\r\n  the bars according to the value of the array\r\n   */\r\n  function updateAnimation(animations) {\r\n    if (startSorting) {\r\n      return;\r\n    }\r\n    setstartSorting(true);\r\n    animations.forEach(([comparison, swapped], index) => {\r\n      setTimeout(() => {\r\n        if (!swapped) {\r\n          if (comparison.length === 2) {\r\n            const [i, j] = comparison;\r\n            setArrayAccessAnimation(i);\r\n            setArrayAccessAnimation(j);\r\n          } else {\r\n            const [i] = comparison;\r\n            setArrayAccessAnimation(i);\r\n          }\r\n        } else {\r\n          setArray((prevArray) => {\r\n            const [k, newValue] = comparison;\r\n            const newArray = [...prevArray];\r\n            newArray[k] = newValue;\r\n            return newArray;\r\n          });\r\n        }\r\n      }, index * MAX_DELAY);\r\n    });\r\n    setTimeout(() => {\r\n      animateSortedArray();\r\n    }, animations.length * MAX_DELAY);\r\n  }\r\n\r\n  function setArrayAccessAnimation(index) {\r\n    const arrayBars = nodeRef.current.children;\r\n    const arrayBarStyle = arrayBars[index].style;\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = COMPARISON_COLOR_1;\r\n    }, MAX_DELAY);\r\n\r\n    setTimeout(() => {\r\n      arrayBarStyle.backgroundColor = COMPARISON_COLOR_2;\r\n    }, MAX_DELAY * 2);\r\n  }\r\n\r\n  function animateSortedArray() {\r\n    const arrayBars = nodeRef.current.children;\r\n    for (let index = 0; index < arrayBars.length; index++) {\r\n      const arrayBarStyle = arrayBars[index].style;\r\n      setTimeout(\r\n        () => (arrayBarStyle.backgroundColor = SORTED_COLOR),\r\n        index * MAX_DELAY\r\n      );\r\n    }\r\n    setTimeout(() => {\r\n      setisSorted(true);\r\n      setstartSorting(false);\r\n    }, arrayBars.length * MAX_DELAY);\r\n  }\r\n  return (\r\n    <>\r\n      <Navbar bg=\"dark\" variant=\"dark\" className=\"topnav\">\r\n        <Navbar.Brand>Sorting Visualization</Navbar.Brand>\r\n        <Navbar.Toggle aria-controls=\"responsive-navbar-nav\" />\r\n        <Navbar.Collapse id=\"responsive-navbar-nav\">\r\n          <Nav className=\"mr-auto\">\r\n            <Nav.Link onClick={resetArray}>Generate New Array</Nav.Link>\r\n            <Nav.Link onClick={bubbleSort}>Bubble Sort</Nav.Link>\r\n            <Nav.Link onClick={insertionSort}>Insertion Sort</Nav.Link>\r\n            {/* <Nav.Link onClick={heapSort}>Heap Sort</Nav.Link> */}\r\n            <Nav.Link onClick={mergeSort}>Merge Sort</Nav.Link>\r\n            <Nav.Link onClick={quickSort}>Quick Sort</Nav.Link>\r\n          </Nav>\r\n        </Navbar.Collapse>\r\n      </Navbar>\r\n      <div className=\"array-container\" ref={nodeRef}>\r\n        {array.map((value, idx) => (\r\n          <div\r\n            className=\"array-bar\"\r\n            style={{ backgroundColor: PRIMARY_COLOR, height: `${value}px` }}\r\n            key={idx}\r\n          ></div>\r\n        ))}\r\n      </div>\r\n    </>\r\n  );\r\n}\r\n\r\nfunction randomIntFromInterval(min, max) {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\nexport default SortingVisualizer;\r\n","import React from \"react\";\nimport \"./App.css\";\nimport SortingVisualizer from \"./SortingVisualizer/SortingVisualizer\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\n// Importing the Bootstrap CSS\nimport \"bootstrap/dist/css/bootstrap.min.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}